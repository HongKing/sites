<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><title>点光源聚光灯阴影</title><link rel="stylesheet" href="../css/main.css"><link rel="stylesheet" href="../css/fontello.css"><link rel="stylesheet" href="../css/style.css"><style>h3{
    padding-left: 10px;
}
label{
    display: inline-block;
    width: 60px;
    padding: 0 10px;
}
span{
    display: inline-block;
    width: 40px;
}</style></head><body><div class="content"><a class="github" href="https://github.com/edwardzhong"><img src="../img/github.png"></a><header class="header"><h1><a href="../index.html">Jeff Zhong's Demo</a></h1></header><div class="main grid"><a class="effect-list" href="../index.html">&larr;&nbsp;effect list</a><h2>点光源聚光灯阴影</h2><p>调节聚光灯位置和角度，拖动鼠标可旋转和缩放画面</p><label for="x">x坐标</label><input id="x" type="range" name="x" step="0.5" min="-5" max="5" value="0"><span id="xt">0</span><br><label for="y">y坐标</label><input id="y" type="range" name="y" step="0.5" min="0" max="10" value="3"><span id="yt">3</span><br><label for="xan">x轴角度</label><input id="xan" type="range" name="xan" step="1" min="0" max="45" value="0"><span id="xat">0</span><br><label for="yan">y轴角度</label><input id="yan" type="range" name="yan" step="1" min="-45" max="45" value="0"><span id="yat">30</span><br><canvas id="canvas" width="600" height="450"></canvas></div><footer class="footer"><p> Copyright &copy; 2017 <a href="https://github.com/edwardzhong">Jeff Zhong</a></p></footer></div><script>(function(){'use strict';var xe=Math.sin,pe=Math.cos,ve=Math.PI,_e=Math.sqrt;function e(e,t,r){const o=new ye(3);return e&&(o[0]=e),t&&(o[1]=t),r&&(o[2]=r),o}function t(e,t,r){return r=r||new ye(3),r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r}function r(e,t,r){return r=r||new ye(3),r[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r}function o(e,t,r){r=r||new ye(3);const o=e[2]*t[0]-e[0]*t[2],i=e[0]*t[1]-e[1]*t[0];return r[0]=e[1]*t[2]-e[2]*t[1],r[1]=o,r[2]=i,r}function i(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function a(e){return _e(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])}function n(e,t){t=t||new ye(3);const r=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],o=_e(r);return 1e-5<o?(t[0]=e[0]/o,t[1]=e[1]/o,t[2]=e[2]/o):(t[0]=0,t[1]=0,t[2]=0),t}function s(e,t){return t=t||new ye(3),t[0]=e[0],t[1]=e[1],t[2]=e[2],t}function d(e){return e=e||new Ee(16),e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function u(e,r){if(r=r||new Ee(16),r===e){let o;return o=e[1],e[1]=e[4],e[4]=o,o=e[2],e[2]=e[8],e[8]=o,o=e[3],e[3]=e[12],e[12]=o,o=e[6],e[6]=e[9],e[9]=o,o=e[7],e[7]=e[13],e[13]=o,o=e[11],e[11]=e[14],e[14]=o,r}const o=e[0],i=e[1],a=e[2],n=e[3],s=e[4],d=e[5],u=e[6],f=e[7],l=e[8],m=e[9],h=e[10],c=e[11],x=e[12],p=e[13],v=e[14],_=e[15];return r[0]=o,r[1]=s,r[2]=l,r[3]=x,r[4]=i,r[5]=d,r[6]=m,r[7]=p,r[8]=a,r[9]=u,r[10]=h,r[11]=v,r[12]=n,r[13]=f,r[14]=c,r[15]=_,r}function f(e,t){t=t||new Ee(16);const r=e[0],o=e[1],i=e[2],a=e[3],n=e[4],s=e[5],u=e[6],f=e[7],l=e[8],m=e[9],h=e[10],c=e[11],x=e[12],p=e[13],v=e[14],_=e[15],y=h*_,E=v*c,T=u*_,b=v*f,w=u*c,g=h*f,z=i*_,S=v*a,C=i*c,A=h*a,F=i*f,M=u*a,D=l*p,L=x*m,R=n*p,B=x*s,P=n*m,I=l*s,O=r*p,N=x*o,U=r*m,V=l*o,G=r*s,W=n*o,X=y*s+b*m+w*p-(E*s+T*m+g*p),k=E*o+z*m+A*p-(y*o+S*m+C*p),H=T*o+S*s+F*p-(b*o+z*s+M*p),Y=g*o+C*s+M*m-(w*o+A*s+F*m),j=1/(r*X+n*k+l*H+x*Y);return t[0]=j*X,t[1]=j*k,t[2]=j*H,t[3]=j*Y,t[4]=j*(E*n+T*l+g*x-(y*n+b*l+w*x)),t[5]=j*(y*r+S*l+C*x-(E*r+z*l+A*x)),t[6]=j*(b*r+z*n+M*x-(T*r+S*n+F*x)),t[7]=j*(w*r+A*n+F*l-(g*r+C*n+M*l)),t[8]=j*(D*f+B*c+P*_-(L*f+R*c+I*_)),t[9]=j*(L*a+O*c+V*_-(D*a+N*c+U*_)),t[10]=j*(R*a+N*f+G*_-(B*a+O*f+W*_)),t[11]=j*(I*a+U*f+W*c-(P*a+V*f+G*c)),t[12]=j*(R*h+I*v+L*u-(P*v+D*u+B*h)),t[13]=j*(U*v+D*i+N*h-(O*h+V*v+L*i)),t[14]=j*(O*u+W*v+B*i-(G*v+R*i+N*u)),t[15]=j*(G*h+P*i+V*u-(U*u+W*h+I*i)),t}function l(e,t,r){r=r||new Ee(16);const o=e[0],i=e[1],a=e[2],n=e[3],s=e[4],d=e[5],u=e[6],f=e[7],l=e[8],m=e[9],h=e[10],c=e[11],x=e[12],p=e[13],v=e[14],_=e[15],y=t[0],E=t[1],T=t[2],b=t[3],w=t[4],g=t[5],z=t[6],S=t[7],C=t[8],A=t[9],F=t[10],M=t[11],D=t[12],L=t[13],R=t[14],B=t[15];return r[0]=o*y+s*E+l*T+x*b,r[1]=i*y+d*E+m*T+p*b,r[2]=a*y+u*E+h*T+v*b,r[3]=n*y+f*E+c*T+_*b,r[4]=o*w+s*g+l*z+x*S,r[5]=i*w+d*g+m*z+p*S,r[6]=a*w+u*g+h*z+v*S,r[7]=n*w+f*g+c*z+_*S,r[8]=o*C+s*A+l*F+x*M,r[9]=i*C+d*A+m*F+p*M,r[10]=a*C+u*A+h*F+v*M,r[11]=n*C+f*A+c*F+_*M,r[12]=o*D+s*L+l*R+x*B,r[13]=i*D+d*L+m*R+p*B,r[14]=a*D+u*L+h*R+v*B,r[15]=n*D+f*L+c*R+_*B,r}function m(e,t,r,o,i){var a=Math.tan;i=i||new Ee(16);const n=a(.5*ve-.5*e),s=1/(r-o);return i[0]=n/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=n,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=(r+o)*s,i[11]=-1,i[12]=0,i[13]=0,i[14]=2*(r*o*s),i[15]=0,i}function h(e,r,i,a){a=a||new Ee(16);const s=Te,d=be,u=we;return n(t(e,r,u),u),n(o(i,u,s),s),n(o(u,s,d),d),a[0]=s[0],a[1]=s[1],a[2]=s[2],a[3]=0,a[4]=d[0],a[5]=d[1],a[6]=d[2],a[7]=0,a[8]=u[0],a[9]=u[1],a[10]=u[2],a[11]=0,a[12]=e[0],a[13]=e[1],a[14]=e[2],a[15]=1,a}function c(e,t){return t=t||new Ee(16),t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}function x(e,t){t=t||new Ee(16);const r=pe(e),o=xe(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=o,t[7]=0,t[8]=0,t[9]=-o,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function p(e,t){t=t||new Ee(16);const r=pe(e),o=xe(e);return t[0]=r,t[1]=0,t[2]=-o,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=o,t[9]=0,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function v(e,t,r){r=r||new Ee(16);const o=e[0],i=e[1],a=e[2],n=e[3],d=e[8],u=e[9],f=e[10],l=e[11],m=pe(t),h=xe(t);return r[0]=m*o-h*d,r[1]=m*i-h*u,r[2]=m*a-h*f,r[3]=m*n-h*l,r[8]=m*d+h*o,r[9]=m*u+h*i,r[10]=m*f+h*a,r[11]=m*l+h*n,e!==r&&(r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r}function _(e,t,r,o){o=o||new Ee(16);let i=t[0],a=t[1],d=t[2];const u=_e(i*i+a*a+d*d);i/=u,a/=u,d/=u;const n=i*i,f=a*a,l=d*d,m=pe(r),h=xe(r),s=1-m,c=n+(1-n)*m,p=i*a*s+d*h,v=i*d*s-a*h,_=i*a*s-d*h,E=f+(1-f)*m,T=a*d*s+i*h,b=i*d*s+a*h,w=a*d*s-i*h,g=l+(1-l)*m,S=e[0],C=e[1],A=e[2],F=e[3],M=e[4],D=e[5],L=e[6],R=e[7],B=e[8],P=e[9],I=e[10],O=e[11];return o[0]=c*S+p*M+v*B,o[1]=c*C+p*D+v*P,o[2]=c*A+p*L+v*I,o[3]=c*F+p*R+v*O,o[4]=_*S+E*M+T*B,o[5]=_*C+E*D+T*P,o[6]=_*A+E*L+T*I,o[7]=_*F+E*R+T*O,o[8]=b*S+w*M+g*B,o[9]=b*C+w*D+g*P,o[10]=b*A+w*L+g*I,o[11]=b*F+w*R+g*O,e!==o&&(o[12]=e[12],o[13]=e[13],o[14]=e[14],o[15]=e[15]),o}function E(t,r,o){o=o||e();const i=r[0],a=r[1],n=r[2],s=i*t[3]+a*t[7]+n*t[11]+t[15];return o[0]=(i*t[0]+a*t[4]+n*t[8]+t[12])/s,o[1]=(i*t[1]+a*t[5]+n*t[9]+t[13])/s,o[2]=(i*t[2]+a*t[6]+n*t[10]+t[14])/s,o}function T(t,r,o){o=o||e();const i=r[0],a=r[1],n=r[2];return o[0]=i*t[0]+a*t[4]+n*t[8],o[1]=i*t[1]+a*t[5]+n*t[9],o[2]=i*t[2]+a*t[6]+n*t[10],o}function b(e,t,r){if(!e)throw new Error("canvas not exist");var o=e.getBoundingClientRect();return{x:(t-o.left)*(e.width/o.width),y:(r-o.top)*(e.height/o.height)}}function w(e,t){var r="mousewheel";try{document.createEvent("MouseScrollEvents"),r="DOMMouseScroll"}catch(t){}e.addEventListener(r,function(r){if("wheelDelta"in r){var e=r.wheelDelta;window.opera&&10>opera.version()&&(e=-e),r.delta=Math.round(e)/120}else"detail"in r&&(r.wheelDelta=40*-r.detail,r.delta=r.wheelDelta/120);t(r)},!1)}function g(e){return Qe[e].bindPoint}function z(e,t){return function(r){e.uniform1i(t,r)}}function S(e,t){return function(r){e.uniform1iv(t,r)}}function C(e,t){return function(r){e.uniform2iv(t,r)}}function A(e,t){return function(r){e.uniform3iv(t,r)}}function F(e,t){return function(r){e.uniform4iv(t,r)}}function M(e,t,r,o){const i=g(t);return O(e)?function(t){let a,n;I(e,t)?(a=t,n=null):(a=t.texture,n=t.sampler),e.uniform1i(o,r),e.activeTexture(e.TEXTURE0+r),e.bindTexture(i,a),e.bindSampler(r,n)}:function(t){e.uniform1i(o,r),e.activeTexture(e.TEXTURE0+r),e.bindTexture(i,t)}}function D(e,t,r,o,a){const n=g(t),s=new Int32Array(a);for(let n=0;n<a;++n)s[n]=r+n;return O(e)?function(t){e.uniform1iv(o,s),t.forEach(function(t,o){e.activeTexture(e.TEXTURE0+s[o]);let i,a;I(e,t)?(i=t,a=null):(i=t.texture,a=t.sampler),e.bindSampler(r,a),e.bindTexture(n,i)})}:function(t){e.uniform1iv(o,s),t.forEach(function(t,r){e.activeTexture(e.TEXTURE0+s[r]),e.bindTexture(n,t)})}}function L(e,t){return function(r){r.value?(e.disableVertexAttribArray(t),e.vertexAttrib4fv(t,r.value)):(e.bindBuffer(e.ARRAY_BUFFER,r.buffer),e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r.num||r.size,r.type||e.FLOAT,r.normalize||!1,r.stride||0,r.offset||0),r.divisor!==void 0&&e.vertexAttribDivisor(t,r.divisor))}}function R(e,t){return function(r){r.value?(e.disableVertexAttribArray(t),e.vertexAttrib4iv(t,r.value)):(e.bindBuffer(e.ARRAY_BUFFER,r.buffer),e.enableVertexAttribArray(t),e.vertexAttribIPointer(t,r.num||r.size,r.type||e.INT,r.stride||0,r.offset||0),r.divisor!==void 0&&e.vertexAttribDivisor(t,r.divisor))}}function B(e,t){return function(r){r.value?(e.disableVertexAttribArray(t),e.vertexAttrib4uiv(t,r.value)):(e.bindBuffer(e.ARRAY_BUFFER,r.buffer),e.enableVertexAttribArray(t),e.vertexAttribIPointer(t,r.num||r.size,r.type||e.UNSIGNED_INT,r.stride||0,r.offset||0),r.divisor!==void 0&&e.vertexAttribDivisor(t,r.divisor))}}function P(e,t,r){const o=r.size,a=r.count;return function(r){e.bindBuffer(e.ARRAY_BUFFER,r.buffer);const n=r.size||r.num||o,s=r.type||e.FLOAT,d=Qe[s],u=d.size*n,f=r.normalize||!1,l=r.offset||0;for(let o=0;o<a;++o)e.enableVertexAttribArray(t+o),e.vertexAttribPointer(t+o,n/a,s,f,u,l+u/a*o),void 0!==r.divisor&&e.vertexAttribDivisor(t+o,r.divisor)}}function I(e,r){return et||(et=e.createTexture()),r instanceof et.constructor}function O(e){return!!e.texStorage2D}function N(e){const t=e.name;return t.startsWith("gl_")||t.startsWith("webgl_")}function U(e,t){rt(e,0);const r=e.getExtension(t);if(r){const o={},i=ot.exec(t)[1];for(const t in r){const a=r[t],n="function"==typeof a,s=n?i:"_"+i;let d=t;t.endsWith(s)&&(d=t.substring(0,t.length-s.length)),e[d]===void 0?n?e[d]=function(e){return function(){return e.apply(r,arguments)}}(a):(e[d]=a,o[d]=a):!n&&e[d]!==a&&console.warn(d,e[d],a,t)}o.constructor={name:r.constructor.name},rt(o,0)}return r}function V(e){for(let t=0;t<tt.length;++t)U(e,tt[t])}function G(e,...t){const r=W(t);return X(e,r)}function W(...e){const t=[];let r,o,i;if((e+"").replace(/[^\,\s]+/g,function(e){e&&t.push(e)}),t.forEach(e=>{if(i=document.getElementById(e),!i)throw"unknown script element "+e;0<=i.type.indexOf("vert")?r=i.text:0<=i.type.indexOf("frag")&&(o=i.text)}),!r)throw"VERTEX_SHADER String not exist";if(!o)throw"FRAGMENT_SHADER String not exist";return[r,o]}function X(e,...t){Array.isArray(t[0])&&(t=t[0]);const r=k(e,e.VERTEX_SHADER,t[0]),o=k(e,e.FRAGMENT_SHADER,t[1]);if(!r)throw"VERTEX_SHADER not exist";if(!o)throw"FRAGMENT_SHADER not exist";const i=e.createProgram();if(!i)throw"program not exist";e.attachShader(i,r),e.attachShader(i,o),e.linkProgram(i);const a=e.getProgramParameter(i,e.LINK_STATUS);if(!a){const t=e.getProgramInfoLog(i);throw e.deleteProgram(i),e.deleteShader(o),e.deleteShader(r),"Failed to link program: "+t.toString()}return i}function k(e,t,r){const o=e.createShader(t);if(!o)throw"unable to create shader";e.shaderSource(o,r),e.compileShader(o);const i=e.getShaderParameter(o,e.COMPILE_STATUS);if(!i){const t=e.getShaderInfoLog(o);throw e.deleteShader(o),"Failed to compile shader: "+t.toString()}return o}function H(e,...t){Array.isArray(t[0])&&(t=t[0]);const r=0<t[0].indexOf("{")?X(e,t):G(e,t),o=j(e,r),i=Y(e,r);return{program:r,uniformSetters:o,attribSetters:i}}function Y(e,t){const r={},o=e.getProgramParameter(t,e.ACTIVE_ATTRIBUTES);for(let a=0;a<o;++a){const o=e.getActiveAttrib(t,a);if(N(o))continue;const i=e.getAttribLocation(t,o.name),n=Ze[o.type],s=n.setter(e,i,n);s.location=i,r[o.name]=s}return r}function j(e,t){function r(t,r){const i=e.getUniformLocation(t,r.name),a=1<r.size&&"[0]"===r.name.substr(-3),n=r.type,s=Qe[n];if(!s)throw"unknown type: 0x"+n.toString(16);let d;if(s.bindPoint){const t=o;o+=r.size,d=a?s.arraySetter(e,n,t,i,r.size):s.setter(e,n,t,i,r.size)}else d=s.arraySetter&&a?s.arraySetter(e,i):s.setter(e,i);return d.location=i,d}let o=0;const a={},n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let o=0;o<n;++o){const i=e.getActiveUniform(t,o);if(N(i))continue;let n=i.name;"[0]"===n.substr(-3)&&(n=n.substr(0,n.length-3));const s=r(t,i);a[n]=s}return a}function q(e,t){e=e.uniformSetters||e,Object.keys(t).forEach(function(r){const o=e[r];o&&o(t[r])})}function K(e,t,r){r.vertexArrayObject?e.bindVertexArray(r.vertexArrayObject):(J(t.attribSetters||t,r.attribs),r.indices&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r.indices))}function J(e,t){e=e.attribSetters||e,Object.keys(t).forEach(function(r){const o=e[r];o&&o(t[r])})}function Q(e,t){const r={attribs:Z(e,t)};let o=t.indices;return o?(o=te(o,"indices"),r.indices=$(e,o,e.ELEMENT_ARRAY_BUFFER),r.count=o.length,r.indexType=oe(o)):r.count=se(t),r}function Z(e,t){const r={};return Object.keys(t).forEach(function(o){if(!ie(o)){const i=t[o],a=i.name||i.attribName||$e.attribPrefix(o),n=te(i,a);r[a]={buffer:$(e,n,void 0,i.drawType),num:i.num||i.size||re(a),type:oe(n),normalize:ne(n),stride:i.stride||0,offset:i.offset||0,divisor:i.divisor,drawType:i.drawType||e.STATIC_DRAW}}}),e.bindBuffer(e.ARRAY_BUFFER,null),r}function $(e,t,r,o){r=r||e.ARRAY_BUFFER;const i=e.createBuffer();return e.bindBuffer(r,i),e.bufferData(r,t,o||e.STATIC_DRAW),i}function ee(e,t,r){const o=e.createVertexArray();return e.bindVertexArray(o),t.length||(t=[t]),t.forEach(function(t){K(e,t,r)}),e.bindVertexArray(null),{count:r.count,indexType:r.indexType,vertexArrayObject:o}}function te(e,t){if(ae(e))return e;if(ae(e.data))return e.data;Array.isArray(e)&&(e={data:e});let r=e.type;return r||(ie(t)?r=Uint16Array:r=Float32Array),new r(e.data)}function re(e,t){let r;if(r=it.test(e)?2:at.test(e)?4:3,0<t%r)throw"Can not guess num for attribute '"+e+"'. Tried "+r+" but "+t+" values is not evenly divisible by "+r+". You should specify it.";return r}function oe(e){if(e instanceof Int8Array)return ge;if(e instanceof Uint8Array)return ze;if(e instanceof Uint8ClampedArray)return ze;if(e instanceof Int16Array)return Se;if(e instanceof Uint16Array)return Ce;if(e instanceof Int32Array)return Le;if(e instanceof Uint32Array)return Xe;if(e instanceof Float32Array)return Ae;throw"unsupported typed array type"}function ie(e){return"indices"===e}function ae(e){return e&&e.buffer&&e.buffer instanceof ArrayBuffer}function ne(e){return!!(e instanceof Int8Array)||!!(e instanceof Uint8Array)}function se(e){let t,r;for(r=0;r<nt.length&&(t=nt[r],!(t in e));++r);r===nt.length&&(t=Object.keys(e)[0]);const o=e[t],a=de(o).length,n=ue(o,t);if(0<a%n)throw"numComponents "+n+" not correct for length "+a;return a/n}function de(e){return e.length?e:e.data}function ue(e,t){return e.num||e.size||re(t,de(e).length)}function fe(e,t,r,o,i){r=r||e.TRIANGLES,o=o||t.count,i=i||0;const a=t.indices,n=t.indexType;n||a?e.drawElements(r,o,n||Ce,i):e.drawArrays(r,i,o)}function le(e,t,r){r=r||e.FRAMEBUFFER,t?(e.bindFramebuffer(r,t.framebuffer),e.viewport(0,0,t.width,t.height)):(e.bindFramebuffer(r,null),e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight))}function me(e,t,r,o){const i=e.createTexture();if(!i)throw"Failed to create texture object";const a=t.target||je,n=t.format||qe,s=t.informat||n,d=t.type||ze;return e.bindTexture(a,i),r&&o&&e.texImage2D(a,0,s,r,o,0,n,d,null),e.texParameteri(a,e.TEXTURE_MIN_FILTER,t.min||Je),e.texParameteri(a,e.TEXTURE_MAG_FILTER,t.mag||Je),e.texParameteri(a,e.TEXTURE_WRAP_T,t.wrapT||Ke),e.texParameteri(a,e.TEXTURE_WRAP_S,t.wrapS||Ke),i}function he(e){const t=c([0,2,2]);v(t,Dt,t);const r=u(f(t));e==vt?(q(e,{u_vpMatrix:Ft,u_modelMatrix:t}),K(pt,e,wt),fe(pt,wt)):(q(e,{u_color:[.9,.3,.3],u_vpMatrix:Mt,u_vpMatrixFromLight:Ft,u_modelMatrix:t,u_normalMatrix:r}),K(pt,e,zt),fe(pt,zt))}function ce(e){const t=d(),r=u(f(t));e==vt?(q(e,{u_vpMatrix:Ft,u_modelMatrix:t}),K(pt,e,bt),fe(pt,bt)):(q(e,{u_color:[.6,.6,.6],u_vpMatrix:Mt,u_vpMatrixFromLight:Ft,u_modelMatrix:t,u_normalMatrix:r}),K(pt,e,gt),fe(pt,gt))}let ye=Float32Array,Ee=Float32Array;const Te=e(),be=e(),we=e(),ge=5120,ze=5121,Se=5122,Ce=5123,Ae=5126,Fe=35664,Me=35665,De=35666,Le=5124,Re=35667,Be=35668,Pe=35669,Ie=35670,Oe=35671,Ne=35672,Ue=35673,Ve=35674,Ge=35675,We=35676,Xe=5125,ke=36294,He=36295,Ye=36296,je=3553,qe=6408,Ke=10497,Je=9729,Qe={};Qe[Ae]={Type:Float32Array,size:4,setter:function(e,t){return function(r){e.uniform1f(t,r)}},arraySetter:function(e,t){return function(r){e.uniform1fv(t,r)}}},Qe[Fe]={Type:Float32Array,size:8,setter:function(e,t){return function(r){e.uniform2fv(t,r)}}},Qe[Me]={Type:Float32Array,size:12,setter:function(e,t){return function(r){e.uniform3fv(t,r)}}},Qe[De]={Type:Float32Array,size:16,setter:function(e,t){return function(r){e.uniform4fv(t,r)}}},Qe[Le]={Type:Int32Array,size:4,setter:z,arraySetter:S},Qe[Re]={Type:Int32Array,size:8,setter:C},Qe[Be]={Type:Int32Array,size:12,setter:A},Qe[Pe]={Type:Int32Array,size:16,setter:F},Qe[Xe]={Type:Uint32Array,size:4,setter:function(e,t){return function(r){e.uniform1ui(t,r)}},arraySetter:function(e,t){return function(r){e.uniform1uiv(t,r)}}},Qe[ke]={Type:Uint32Array,size:8,setter:function(e,t){return function(r){e.uniform2uiv(t,r)}}},Qe[He]={Type:Uint32Array,size:12,setter:function(e,t){return function(r){e.uniform3uiv(t,r)}}},Qe[Ye]={Type:Uint32Array,size:16,setter:function(e,t){return function(r){e.uniform4uiv(t,r)}}},Qe[Ie]={Type:Uint32Array,size:4,setter:z,arraySetter:S},Qe[Oe]={Type:Uint32Array,size:8,setter:C},Qe[Ne]={Type:Uint32Array,size:12,setter:A},Qe[Ue]={Type:Uint32Array,size:16,setter:F},Qe[Ve]={Type:Float32Array,size:16,setter:function(e,t){return function(r){e.uniformMatrix2fv(t,!1,r)}}},Qe[Ge]={Type:Float32Array,size:36,setter:function(e,t){return function(r){e.uniformMatrix3fv(t,!1,r)}}},Qe[We]={Type:Float32Array,size:64,setter:function(e,t){return function(r){e.uniformMatrix4fv(t,!1,r)}}},Qe[35685]={Type:Float32Array,size:24,setter:function(e,t){return function(r){e.uniformMatrix2x3fv(t,!1,r)}}},Qe[35686]={Type:Float32Array,size:32,setter:function(e,t){return function(r){e.uniformMatrix2x4fv(t,!1,r)}}},Qe[35687]={Type:Float32Array,size:24,setter:function(e,t){return function(r){e.uniformMatrix3x2fv(t,!1,r)}}},Qe[35688]={Type:Float32Array,size:48,setter:function(e,t){return function(r){e.uniformMatrix3x4fv(t,!1,r)}}},Qe[35689]={Type:Float32Array,size:32,setter:function(e,t){return function(r){e.uniformMatrix4x2fv(t,!1,r)}}},Qe[35690]={Type:Float32Array,size:48,setter:function(e,t){return function(r){e.uniformMatrix4x3fv(t,!1,r)}}},Qe[35678]={Type:null,size:0,setter:M,arraySetter:D,bindPoint:je},Qe[35680]={Type:null,size:0,setter:M,arraySetter:D,bindPoint:34067},Qe[35679]={Type:null,size:0,setter:M,arraySetter:D,bindPoint:32879},Qe[36289]={Type:null,size:0,setter:M,arraySetter:D,bindPoint:35866};const Ze={};Ze[Ae]={size:4,setter:L},Ze[Fe]={size:8,setter:L},Ze[Me]={size:12,setter:L},Ze[De]={size:16,setter:L},Ze[Le]={size:4,setter:R},Ze[Re]={size:8,setter:R},Ze[Be]={size:12,setter:R},Ze[Pe]={size:16,setter:R},Ze[Xe]={size:4,setter:B},Ze[ke]={size:8,setter:B},Ze[He]={size:12,setter:B},Ze[Ye]={size:16,setter:B},Ze[Ie]={size:4,setter:R},Ze[Oe]={size:8,setter:R},Ze[Ne]={size:12,setter:R},Ze[Ue]={size:16,setter:R},Ze[Ve]={size:4,setter:P,count:2},Ze[Ge]={size:9,setter:P,count:3},Ze[We]={size:16,setter:P,count:4};const $e={addExtensionsToContext:!0,attribPrefix:e=>"a"+e[0].toUpperCase()+e.substr(1)};let et;const tt=["ANGLE_instanced_arrays","EXT_blend_minmax","EXT_color_buffer_float","EXT_color_buffer_half_float","EXT_disjoint_timer_query","EXT_disjoint_timer_query_webgl2","EXT_frag_depth","EXT_sRGB","EXT_shader_texture_lod","EXT_texture_filter_anisotropic","OES_element_index_uint","OES_standard_derivatives","OES_texture_float","OES_texture_float_linear","OES_texture_half_float","OES_texture_half_float_linear","OES_vertex_array_object","WEBGL_color_buffer_float","WEBGL_compressed_texture_atc","WEBGL_compressed_texture_etc1","WEBGL_compressed_texture_pvrtc","WEBGL_compressed_texture_s3tc","WEBGL_compressed_texture_s3tc_srgb","WEBGL_depth_texture","WEBGL_draw_buffers"],rt=function(){function e(e){const o=e.constructor.name;if(!t[o]){for(const t in e)if("number"==typeof e[t]){const o=r[e[t]];r[e[t]]=o?`${o} | ${t}`:t}t[o]=!0}}const t={},r={};return function(t,o){return e(t),r[o]||"0x"+o.toString(16)}}(),ot=/^(.*?)_/,it=/coord|texture/i,at=/color|colour/i,nt=["position","positions","a_position"];const st=document.getElementById("canvas"),dt=document.getElementById("xt"),y=document.getElementById("yt"),ut=document.getElementById("xat"),ft=document.getElementById("yat");let lt=[0,3,12],mt=[0,3,6],ht=[0,3,6],ct=0,xt=0;const pt=function(e,t){const r=["webgl","experimental-webgl"];let o=null;for(let a=0,i=r.length;a<i;a++)if(o=e.getContext(r[a],t),o){$e.addExtensionsToContext&&V(o);break}return o}(st,!0),vt=H(pt,"#define GLSLIFY 1\nattribute vec4 aPosition; \nuniform mat4 u_vpMatrix; \nuniform mat4 u_modelMatrix; \n\nvoid main() { \n    gl_Position = u_vpMatrix * u_modelMatrix * aPosition; \n}","precision highp float;\n#define GLSLIFY 1\nconst vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);//\u4F7F\u7528rgba 4\u5B57\u8282\u517132\u4F4D\u6765\u5B58\u50A8z\u503C,1\u4E2A\u5B57\u8282\u7CBE\u5EA6\u4E3A1/256\nconst vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0);\nvec4 packDepth (float depth) {\n    //gl_FragCoord:\u7247\u5143\u7684\u5750\u6807,fract():\u8FD4\u56DE\u6570\u503C\u7684\u5C0F\u6570\u90E8\u5206\n    //\u8BE5\u7247\u5143\u7740\u8272\u5668\u76EE\u7684\u662F\u8BA1\u7B97\u6BCF\u4E2A\u7247\u5143\u7684\u6DF1\u5EA6\u503Cz,\u5E76\u628Az\u503C\u4FDD\u5B58\u5230gl_FragColor\u4E2D,\u53EF\u4EE5\u628A\u8BE5\u7EB9\u7406\u770B\u6210\u662F\u6DF1\u5EA6\u503Cz\u7684\u5BB9\u5668,\u56E0\u4E3A\u5B83\u5E76\u4E0D\u4F1A\u6E32\u67D3\u51FA\u6765\n    vec4 rgbaDepth = fract(depth * bitShift); //\u8BA1\u7B97\u6BCF\u4E2A\u70B9\u7684z\u503C \n    rgbaDepth -= rgbaDepth.gbaa * bitMask; //Cut off the value which do not fit in 8 bits\n    return rgbaDepth;\n}\n\nvoid main() {\n    gl_FragColor = packDepth(gl_FragCoord.z);//\u5C06z\u503C\u5206\u5F00\u5B58\u50A8\u5230rgba\u5206\u91CF\u4E2D,\u9634\u5F71\u989C\u8272\u53D8\u91CF\u5B58\u50A8\u7684\u4E0D\u518D\u662F\u989C\u8272\u800C\u53EA\u662F\u6DF1\u5EA6\u503Cz\n}"),_t=H(pt,"#define GLSLIFY 1\nattribute vec4 aPosition;\nattribute vec4 aNormal;\nuniform mat4 u_modelMatrix;//\u7B49\u6BD4\u4F8B\u53D8\u6362,\u53EF\u4EE5\u7528\u6A21\u578B\u77E9\u9635\u4EE3\u66FF\u9006\u8F6C\u7F6E\u77E9\u9635\nuniform mat4 u_vpMatrix;//\u5F53\u524D\u89C6\u70B9\u89C2\u6D4B\u7684\u6A21\u578B\u89C6\u56FE\u6295\u5F71\u77E9\u9635\nuniform mat4 u_vpMatrixFromLight;//\u5149\u6E90\u5904\u89C2\u5BDF\u7684\u6A21\u578B\u89C6\u56FE\u6295\u5F71\u77E9\u9635\nuniform mat4 u_normalMatrix;\nvarying vec4 vShadowCoord;\nvarying vec4 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n    gl_Position = u_vpMatrix * u_modelMatrix * aPosition; // \u5F53\u524D\u89C6\u70B9\u89C2\u5BDF\u5230\u7684\u5750\u6807\n    vShadowCoord = u_vpMatrixFromLight * u_modelMatrix * aPosition;//\u5149\u6E90\u5904\u89C2\u5BDF\u5230\u7684\u5750\u6807,\u7528\u4E8E\u540E\u7EED\u5206\u89E3\u51FAz\u503C\n    vPosition = u_modelMatrix * aPosition;//\u9876\u70B9\u5728\u4E16\u754C\u5750\u6807\u7CFB\u4E2D\u7684\u4F4D\u7F6E\n    vNormal = vec3(u_normalMatrix * aNormal);\n}","precision highp float;\n#define GLSLIFY 1\nuniform vec3 u_lightColor;\nuniform vec3 u_lightPosition;\nuniform vec3 u_lightDirection;//\u5149\u6E90\u65B9\u5411(\u805A\u5149\u706F\u671D\u5411)\nuniform vec3 u_ambientColor;\nuniform vec3 u_viewPosition;\nuniform vec3 u_color;\nconst float shininess = 50.0;\nconst vec3 specularColor = vec3(1.0,1.0,1.0);\nvarying vec4 vPosition;\nvarying vec3 vNormal;\nvarying vec4 vShadowCoord;\nuniform sampler2D uShadowMap;\n#define USE_SHADOWMAP\n// #define SHADOWMAP_PCF_SOFT\n\nconst vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0 * 256.0), 1.0/(256.0 * 256.0 * 256.0));\nfloat unpackDepth(const in vec4 rgbaDepth) {\n    return dot(rgbaDepth,bitShift);\n}\nfloat texture2DCompare(sampler2D depths, vec2 uv, float compare){\n    float depth = unpackDepth(texture2D(depths,uv));\n    return step(compare, depth);\n}\nfloat texture2DShadowLerp(sampler2D depths, vec2 size, vec2 uv, float compare) {\n    const vec2 offset = vec2( 0.0, 1.0 );\n    vec2 texelSize = vec2( 1.0 ) / size;\n    vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n    float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n    float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n    float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n    float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n    vec2 f = fract( uv * size + 0.5 );\n    float a = mix( lb, lt, f.y );\n    float b = mix( rb, rt, f.y );\n    float c = mix( a, b, f.x );\n    return c;\n}\nfloat getShadow(sampler2D shadowMap, vec2 shadowMapSize, float bias, vec4 shadowCoord) {\n    float shadow = 1.0;\n    shadowCoord.xyz = shadowCoord.xyz/shadowCoord.w * 0.5 + 0.5;//\u5C06xyz\u4ECE\u5750\u6807\u533A\u95F4[-1,1]\u8F6C\u6362\u4E3A\u7EB9\u7406\u533A\u95F4[0,1]\uFF0C\u5176\u4E2Dxy\u5206\u91CF\u7528\u4E8E\u67E5\u627E\u7EB9\u7406\u989C\u8272\u503Crgba\uFF0Cz\u5206\u91CF\u662F\u5728\u5149\u6E90\u5750\u6807\u7CFB\u4E0B\u7684\u6DF1\u5EA6\u503C; \n    shadowCoord.z -= bias;\n    //\u68C0\u6D4B\u662F\u5426\u5728\u8D34\u56FE\u8303\u56F4\u5185\uFF0C\u5728\u8D34\u56FE\u8986\u76D6\u8303\u56F4\u5185\u624D\u8FDB\u884C\u9634\u5F71\u6BD4\u8F83\n    bvec4 inFrustumVec = bvec4(shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0);\n    bool inFrustum = all(inFrustumVec);\n    bvec2 frustumTestVec = bvec2(inFrustum, shadowCoord.z <= 1.0);\n    bool frustumTest = all(frustumTestVec);\n    if (frustumTest) {\n    #if defined( SHADOWMAP_PCF )\n        vec2 texelSize = vec2(1.0) / shadowMapSize;\n        float dx0 = - texelSize.x;\n        float dy0 = - texelSize.y;\n        float dx1 = + texelSize.x;\n        float dy1 = + texelSize.y;\n        shadow = (\n            texture2DCompare(shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z) +\n            texture2DCompare(shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z) +\n            texture2DCompare(shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z) +\n            texture2DCompare(shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z) +\n            texture2DCompare(shadowMap, shadowCoord.xy, shadowCoord.z ) +\n            texture2DCompare(shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z) +\n            texture2DCompare(shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z) +\n            texture2DCompare(shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z) +\n            texture2DCompare(shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z)\n        ) * ( 1.0 / 9.0 );\n    #elif defined( SHADOWMAP_PCF_SOFT )\n        vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n        float dx0 = - texelSize.x;\n        float dy0 = - texelSize.y;\n        float dx1 = + texelSize.x;\n        float dy1 = + texelSize.y;\n        shadow = (\n            texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n            texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n            texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n            texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n            texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n            texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n            texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n            texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n            texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n        ) * ( 1.0 / 9.0 );\n    #else\n        shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n    #endif\n    }\n    return shadow;\n}\n\nvoid main() {\n    // \u5BF9\u6CD5\u7EBF\u5F52\u4E00\u5316\uFF0C\u56E0\u4E3A\u5176\u5185\u63D2\u4E4B\u540E\u957F\u5EA6\u4E0D\u4E00\u5B9A\u662F1\n    vec3 normal = normalize(vNormal);\n    // \u70B9\u5149\u6E90\u53CD\u5411 \u5149\u6E90\u4F4D\u7F6E-\u9876\u70B9\u4F4D\u7F6E\n    vec3 surfaceToLightDirection = normalize(u_lightPosition - vPosition.xyz);\n    // \u5149\u7EBF\u65B9\u5411\u548C\u6CD5\u5411\u91CF\u7684\u5939\u89D2\uFF0C\u5B83\u4EEC\u7684\u70B9\u79EF\u5373\u53EF\u6C42\u51FA\u5939\u89D2\u4F59\u5F26\u503C(\u8303\u56F40-90\u5EA6)\n    float cosTheta = max(dot(surfaceToLightDirection, normal), 0.0);\n\n    /*\n    * \u805A\u5149\u706F\n    */\n    float limit = cos(radians(25.0));//\u7167\u5C04\u8303\u56F4\u89D2\u5EA6\n    float outerLimit = cos(radians(25.0));//\u6A21\u7CCA\u5916\u5F84\u89D2\u5EA6\n    float innerLimit = cos(radians(20.0));//\u6A21\u7CCA\u5185\u5F84\u89D2\u5EA6\n    vec3 lightDir = normalize(u_lightDirection);\n    float dotFromDirection = dot(surfaceToLightDirection, lightDir);//\u5149\u6E90\u65B9\u5411\u4E0E\u8868\u9762\u5149\u7EBF\u65B9\u5411\u7684\u5939\u89D2\n    float inlightBloom = smoothstep(outerLimit, innerLimit, dotFromDirection);//\u805A\u5149\u706F\u8303\u56F4 + \u8FB9\u7F18\u6A21\u7CCA\n    // \u805A\u5149\u706F\u8303\u56F4\n    float inLight = step(limit, dotFromDirection);\n\n    // \u73AF\u5883\u5149\n    vec3 ambient = u_ambientColor * u_color;\n    // \u6F2B\u53CD\u5C04\n    vec3 diffuse = u_lightColor * u_color * cosTheta * inlightBloom;\n    \n    // \u9AD8\u5149\n    vec3 viewDirection = normalize(u_viewPosition - vPosition.xyz);// \u53CD\u5C04\u65B9\u5411\n    vec3 halfwayDir = normalize(surfaceToLightDirection + viewDirection);\n    float specularIntensity = pow(max(dot(normal, halfwayDir), 0.0), shininess);\n    vec3 specular = specularColor * specularIntensity * inlightBloom;\n\n    //\u9634\u5F71(\u805A\u5149\u706F\u8303\u56F4\u5916\u65E0\u9634\u5F71)\n    //float shadow = dotFromDirection > limit ? pcf(cosTheta,vPositionFromLight) : 1.0;\n    // float shadow = min(inLight, pcf(cosTheta,vPositionFromLight));\n    vec2 shadowMapSize = vec2(2048.0);\n    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);\n    float shadow = min(inLight,getShadow(uShadowMap,shadowMapSize,bias,vShadowCoord));\n\n    gl_FragColor = vec4(ambient + (diffuse + specular) * shadow , 1.0);        \n}"),yt=function(t,r,o,a){o=o||t.drawingBufferWidth,a=a||t.drawingBufferHeight;const n=t.createFramebuffer();if(!n)throw"Failed to create frame buffer object";t.bindFramebuffer(t.FRAMEBUFFER,n);const s={framebuffer:n,textures:[],width:o,height:a},d=r.texs||1,u=!!r.depth;r.wrapT=r.wrapS=33071;for(let e=0;e<d;e++){const i=me(t,r,o,a);t.generateMipmap(je),s.textures.push(i),t.framebufferTexture2D(t.FRAMEBUFFER,36064+e,je,i,0)}if(u){const e=t.createRenderbuffer();if(!e)throw"Failed to create renderbuffer object";t.bindRenderbuffer(t.RENDERBUFFER,e),t.renderbufferStorage(t.RENDERBUFFER,33189,o,a),t.framebufferRenderbuffer(t.FRAMEBUFFER,36096,t.RENDERBUFFER,e)}const f=t.checkFramebufferStatus(t.FRAMEBUFFER);if(t.FRAMEBUFFER_COMPLETE!==f)throw"Frame buffer object is incomplete: "+f.toString();return t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindTexture(je,null),u&&t.bindRenderbuffer(t.RENDERBUFFER,null),s}(pt,{depth:!0},2048,2048),Et=Q(pt,function(e){return{position:[-e,0,-e,-e,0,e,e,0,-e,e,0,-e,-e,0,e,e,0,e,e,0,-e,-e,0,e,-e,0,-e,e,0,e,-e,0,e,e,0,-e],normal:[0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],texcoord:[0,1,0,0,1,1,1,1,0,0,1,0,1,1,0,0,0,1,1,0,0,0,1,1]}}(5)),Tt=Q(pt,function(e){e=e||1;var t=[-e,-e,-e,-e,e,-e,e,-e,-e,-e,e,-e,e,e,-e,e,-e,-e,-e,-e,e,e,-e,e,-e,e,e,-e,e,e,e,-e,e,e,e,e,-e,e,-e,-e,e,e,e,e,-e,-e,e,e,e,e,e,e,e,-e,-e,-e,-e,e,-e,-e,-e,-e,e,-e,-e,e,e,-e,-e,e,-e,e,-e,-e,-e,-e,-e,e,-e,e,-e,-e,-e,e,-e,e,e,-e,e,-e,e,-e,-e,e,e,-e,e,-e,e,e,-e,e,e,e,-e,e,e,e];return{position:t,normal:[0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0]}}()),bt=ee(pt,vt,Et),wt=ee(pt,vt,Tt),gt=ee(pt,_t,Et),zt=ee(pt,_t,Tt),St=function(t,o,d,u,f){function l(r){var e=Math.acos,o=b(t,r.clientX,r.clientY),a=2*((g.y>v.y?g.x-o.x:o.x-g.x)/c*ve),d=(g.y-o.y)/x*ve,u=C[1],f=e(i(n(C),n([0,u,0]))),l=p(a);f+d<ve/90&&0<u&&0>d&&(d=ve/180-f),f-d<ve/90&&0>u&&0<d&&(d=f-ve/180);var m=T(p(-ve/2),[C[0],0,C[2]]),h=_(l,m,-d);S=s(E(h,C))}function m(){C=s(S),t.removeEventListener("mouseup",m,!1),t.removeEventListener("mousemove",l,!1),t.removeEventListener("mouseout",m,!1)}if(!t)throw new Error("canvas not exist");f=f||[0,0,0],o=o||[0,5,5],d=d||1,u=u||50;var h,c=t.clientWidth,x=t.clientHeight,v={x:c/2,y:x/2},g=v,z=1,S=o,C=o;return w(t,function(t){var e=a(C);e<d+1&&0>t.delta||e>u-1&&0<t.delta||(z+=.05*t.delta,S=r(C,z),clearTimeout(h),h=setTimeout(function(){z=1,C=s(S)},20))}),t.addEventListener("mousedown",function(r){g=b(t,r.clientX,r.clientY),t.addEventListener("mousemove",l,!1),t.addEventListener("mouseup",m,!1),t.addEventListener("mouseout",m,!1)},!1),function(){return S}}(st,lt,1,100),Ct=m(ve/2,1,1,100),At=m(ve/6,st.width/st.height,1,100);let Ft=d(),Mt=d(),Dt=0;(function(e,t){var r=Math.floor;t=t||window.devicePixelRatio;var o=e.width,i=e.height,a=r(e.clientWidth*t),n=r(e.clientHeight*t);(o!==a||i!==n)&&(e.width=a,e.height=n,e.style.width=o+"px",e.style.height=i+"px")})(st),pt.clearColor(0,0,0,1),pt.enable(pt.DEPTH_TEST),pt.enable(pt.CULL_FACE),function e(){lt=St();const t=h(mt,[0,0,0],[0,1,0]);l(Ct,f(t),Ft);const r=h(lt,[0,0,0],[0,1,0]);l(At,f(r),Mt),Dt=(Dt+.01)%(2*ve),le(pt,yt),pt.clear(pt.COLOR_BUFFER_BIT|pt.DEPTH_BUFFER_BIT),pt.useProgram(vt.program),he(vt),ce(vt),le(pt),pt.clear(pt.COLOR_BUFFER_BIT|pt.DEPTH_BUFFER_BIT),pt.useProgram(_t.program),q(_t,{uShadowMap:yt.textures[0],u_lightColor:[1,1,1],u_lightPosition:mt,u_lightDirection:ht,u_ambientColor:[.2,.2,.2],u_viewPosition:lt}),he(_t),ce(_t),requestAnimationFrame(e)}(),document.getElementById("x").oninput=function(){dt.innerText=mt[0]=+this.value},document.getElementById("y").oninput=function(){y.innerText=mt[1]=+this.value},document.getElementById("xan").oninput=function(){ut.innerText=this.value,ct=+this.value*ve/180,Lt()},document.getElementById("yan").oninput=function(){ft.innerText=this.value,xt=+this.value*ve/180,Lt()};const Lt=()=>{var e=x(-ct);e=v(e,-xt),ht=n(T(e,mt))};Lt()})();
</script></body></html>